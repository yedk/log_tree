# 程序结构
|text | data | bss | heap | mmap | stack|



链接就是将多个目标文件里的代码，统一放到一个文件里。
# 静态链接
对于库，只链接需要的函数
对于多个目标文件，所有的函数都会放到可执行程序里面
。每个函数根据地址进行重新定位，编译器完成的。

在一个多进程环境中，多个进程执行相同的函数，通过静态链接则会有大量的重复代码。

在linux环境下，操作系统首先fork一个子进程，接着动态链接器被加载到内存中，操作系统将控制权交给动态链接器，让动态链接器完成动态库的加载和重定位操作。
动态链接器本神也是一个库ld-linux.so 。动态链接器解析可执行文件中未确定的符号及需要链接的动态库信息。将对应的库加载到内存中，并进行重定位操作。

将执行程序里面的绝对变量分离出来，放到一个GOT表中，这样在程序运行到这些绝对变量的时候，通过GOT表来查询这些绝对变量的地址。动态链接库里也有一个got表，库里面引用的外部变量会放到这个表里面，加载动态链接库的时候会将got表中的变量进行填充。
程序第一次运行的时候，遇到动态库里的函数会指向plt表，plt指向got.plt表，在got中第一次存储的是调用会执行动态链接器的地址（指向plt的第二行），动态链接器将要调用的函数库加载进来并改写got表，第二次调用该函数则会直接跳到动态库去执行函数。
Q: 为什么不从程序里直接跳到GOT里面，还要经过plt？
A: plt表里存了调用动态链接器的函数。
# 动态链接
运行的时候才会链接，程序加载进入后，调用函数会指向plt表，plt指向got表，通过got将动态链接库加载进来，并将调用的函数地址进行修改。
一般代码段不能修改，所以修改got段。
如果存在多个进程，调用相同的库函数，如果一个进程结束，会释放内存。是不是几个进程共用一个got段呢？
```code
在程序运行时，每个进程都会有自己的GOT（全局偏移表）和PLT（过程链接表），因为它们都是进程的内存映像的一部分。因此，多个进程不会共用同一个GOT。

在程序编译时，GOT和PLT是在可执行文件中静态定义的。在程序运行时，操作系统会将可执行文件中的代码和数据加载到内存中，并为每个进程创建一个独立的内存映像。每个进程都有自己的GOT和PLT，因此它们不会共享同一个GOT。

需要注意的是，如果多个进程都运行同一个可执行文件，它们会共享同一个可执行文件的代码段和数据段，但是每个进程都会有自己的GOT和PLT。
```
通过链接过程，可以明白为什么需要两张表。
首先是main.c文件调用动态库里的函数，这个函数地址链接的时候不知道，所以需要一段代码获取这个地址，然后将这个地址回写到一个地址，这个地址必须在数据段。存储这个地址的地方就叫got表,这个获取地址的代码段就是plt表。plt表是在代码段，链接时提供（动态库）调用函数的暂时地址。这些暂时地址指向got。
